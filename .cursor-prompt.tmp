‚ö†Ô∏è CRITICAL EXECUTION RULES - READ FIRST ‚ö†Ô∏è
‚ùå NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
‚ùå NEVER run: long-running processes, servers, or commands that don't exit
‚ùå NEVER test the application by starting it
‚úÖ ALLOWED: npm install, npm run build, npm run test (if needed)
‚úÖ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
‚ö†Ô∏è The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

CRITICAL: Follow the boilerplate guidelines below EXACTLY. These are the official standards for this project.



=== REACT BOILERPLATE DOCUMENTATION ===
# Enhanced Vite + React (TS) + Tailwind v3 + Shadcn Boilerplate (Lovable-Compatible)

## Overview
A streamlined, modern React boilerplate built for rapid development and prototyping. This boilerplate features Vite, TypeScript, **Tailwind CSS v3**, shadcn/ui components, React Router, React Query, and **Recharts** for data visualization - optimized to match Lovable's approach.

## Tech Stack
- **Language:** TypeScript
- **Framework:** React 18 + **Vite**
- **Routing:** `react-router-dom` v6
- **Styling/UI:** **Tailwind CSS v3**, **shadcn/ui** (Radix), `class-variance-authority`, `tailwind-merge`, `tailwindcss-animate`
- **Typography:** **@tailwindcss/typography** for rich text content
- **Animations:** **Tailwind CSS animations** + custom keyframes
- **Forms & Validation:** `react-hook-form`, `zod`, `@hookform/resolvers`
- **Data Fetching:** **@tanstack/react-query** + **native fetch()**
- **Charts:** **Recharts** for data visualization
- **Icons:** **lucide-react**
- **Linting/Types:** ESLint, TypeScript

## Project Structure
```
my-app/
‚îú‚îÄ index.html
‚îú‚îÄ package.json
‚îú‚îÄ tsconfig.json
‚îú‚îÄ vite.config.ts
‚îú‚îÄ components.json     # shadcn/ui config
‚îú‚îÄ .env               # local env (never commit)
‚îú‚îÄ .env.example       # documents required env vars
‚îî‚îÄ src/
   ‚îú‚îÄ main.tsx        # mounts <App />
   ‚îú‚îÄ App.tsx         # Router + Providers (QueryClient, Theme, Toast)
   ‚îú‚îÄ index.css       # Enhanced with CSS custom properties
   ‚îú‚îÄ pages/
   ‚îÇ  ‚îú‚îÄ Home.tsx
   ‚îÇ  ‚îú‚îÄ ProjectDetails.tsx
   ‚îÇ  ‚îî‚îÄ NotFound.tsx
   ‚îú‚îÄ components/
   ‚îÇ  ‚îú‚îÄ ui/          # shadcn-generated components (button, input, card, ...)
   ‚îÇ  ‚îú‚îÄ layout/      # Layout components (Navbar, Footer, etc.)
   ‚îÇ  ‚îî‚îÄ charts/      # Recharts components
   ‚îú‚îÄ hooks/          # custom hooks
   ‚îÇ  ‚îú‚îÄ useProjects.ts
   ‚îÇ  ‚îî‚îÄ use-toast.ts
   ‚îú‚îÄ lib/
   ‚îÇ  ‚îú‚îÄ utils.ts     # cn() via clsx + tailwind-merge, helpers
   ‚îÇ  ‚îî‚îÄ api.ts       # Fetch-based API utilities
   ‚îú‚îÄ types/
   ‚îÇ  ‚îî‚îÄ project.ts
   ‚îî‚îÄ contexts/
```

## Dependencies
```jsonc
// package.json (essentials)
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1",
  "react-router-dom": "^6.30.1",
  "@tanstack/react-query": "^5.83.0",
  "react-hook-form": "^7.61.1",
  "@hookform/resolvers": "^3.10.0",
  "zod": "^3.25.76",
  "clsx": "^2.1.1",
  "class-variance-authority": "^0.7.1",
  "tailwind-merge": "^2.6.0",
  "tailwindcss-animate": "^1.0.7",
  "lucide-react": "^0.462.0",
  "sonner": "^1.7.4",
  "date-fns": "^3.6.0",
  "recharts": "^2.15.4",
  
  // Complete Radix UI Component Suite (from itinerary-orchestra)
  "@radix-ui/react-accordion": "^1.2.11",
  "@radix-ui/react-alert-dialog": "^1.1.14",
  "@radix-ui/react-aspect-ratio": "^1.1.7",
  "@radix-ui/react-avatar": "^1.1.10",
  "@radix-ui/react-checkbox": "^1.3.2",
  "@radix-ui/react-collapsible": "^1.1.11",
  "@radix-ui/react-context-menu": "^2.2.15",
  "@radix-ui/react-dialog": "^1.1.14",
  "@radix-ui/react-dropdown-menu": "^2.1.15",
  "@radix-ui/react-hover-card": "^1.1.14",
  "@radix-ui/react-label": "^2.1.7",
  "@radix-ui/react-menubar": "^1.1.15",
  "@radix-ui/react-navigation-menu": "^1.2.13",
  "@radix-ui/react-popover": "^1.1.14",
  "@radix-ui/react-progress": "^1.1.7",
  "@radix-ui/react-radio-group": "^1.3.7",
  "@radix-ui/react-scroll-area": "^1.2.9",
  "@radix-ui/react-select": "^2.2.5",
  "@radix-ui/react-separator": "^1.1.7",
  "@radix-ui/react-slider": "^1.3.5",
  "@radix-ui/react-slot": "^1.2.3",
  "@radix-ui/react-switch": "^1.2.5",
  "@radix-ui/react-tabs": "^1.1.12",
  "@radix-ui/react-toast": "^1.2.14",
  "@radix-ui/react-toggle": "^1.1.9",
  "@radix-ui/react-toggle-group": "^1.1.10",
  "@radix-ui/react-tooltip": "^1.2.7",
  
  // Additional UI packages
  "cmdk": "^1.1.1",
  "embla-carousel-react": "^8.6.0",
  "input-otp": "^1.4.2",
  "react-day-picker": "^8.10.1",
  "react-resizable-panels": "^2.1.9",
  "vaul": "^0.9.9",
  "next-themes": "^0.3.0"
},
"devDependencies": {
  "vite": "^5.4.19",
  "typescript": "^5.8.3",
  "@vitejs/plugin-react-swc": "^3.11.0",
  "tailwindcss": "^3.4.17",
  "@tailwindcss/typography": "^0.5.16",
  "eslint": "^9.32.0",
  "@types/react": "^18.3.23",
  "@types/react-dom": "^18.3.7",
  "postcss": "^8.5.6",
  "autoprefixer": "^10.4.21"
}
```

## ‚ö†Ô∏è Critical Setup Steps for AI Agents

**IMPORTANT:** When working on a React project, you MUST follow these steps in order:

### 1. After Modifying package.json - ALWAYS Run npm install

```bash
npm install
```

**Why this matters:**
- Installing dependencies is NOT automatic when you modify `package.json`
- TypeScript, Vite, and all libraries must be installed before building
- Missing dependencies cause cryptic build errors

**Common errors fixed by npm install:**
- `Cannot find module 'typescript'` ‚Üí Run `npm install`
- `vite: command not found` ‚Üí Run `npm install`
- `Module not found: Can't resolve 'react'` ‚Üí Run `npm install`
- Any `ENOENT` or path resolution errors ‚Üí Run `npm install`

### 2. Before Running Build Commands

NEVER run `npm run build` or `npm run dev` without first running `npm install`:

```bash
# ‚úÖ CORRECT ORDER
npm install
npm run build

# ‚ùå WRONG - Will fail with missing module errors
npm run build
```

### 3. After Cloning or Creating a Project

```bash
cd project-directory
npm install          # Install all dependencies first
npm run dev          # Then start development
```

### 4. Troubleshooting Build Errors

If you encounter build errors:

1. **First, always try:** `npm install`
2. Check that `package.json` has all required dependencies
3. Verify `node_modules/` directory exists and has content
4. Check that TypeScript is installed: `npx tsc --version`
5. Only then investigate the specific error message

**Remember:** 90% of initial build errors are caused by missing dependencies!

## Quickstart
```bash
# 1) Create project
npm create vite@latest my-app -- --template react-ts
cd my-app

# 2) Install core dependencies
npm install react@^18.3.1 react-dom@^18.3.1 react-router-dom@^6.30.1 \
  @tanstack/react-query@^5.83.0 \
  react-hook-form@^7.61.1 @hookform/resolvers@^3.10.0 zod@^3.25.76 \
  clsx@^2.1.1 class-variance-authority@^0.7.1 tailwind-merge@^2.6.0 \
  tailwindcss-animate@^1.0.7 lucide-react@^0.462.0 \
  sonner@^1.7.4 date-fns@^3.6.0 recharts@^2.15.4 \
  @radix-ui/react-accordion@^1.2.11 @radix-ui/react-alert-dialog@^1.1.14 \
  @radix-ui/react-aspect-ratio@^1.1.7 @radix-ui/react-avatar@^1.1.10 \
  @radix-ui/react-checkbox@^1.3.2 @radix-ui/react-collapsible@^1.1.11 \
  @radix-ui/react-context-menu@^2.2.15 @radix-ui/react-dialog@^1.1.14 \
  @radix-ui/react-dropdown-menu@^2.1.15 @radix-ui/react-hover-card@^1.1.14 \
  @radix-ui/react-label@^2.1.7 @radix-ui/react-menubar@^1.1.15 \
  @radix-ui/react-navigation-menu@^1.2.13 @radix-ui/react-popover@^1.1.14 \
  @radix-ui/react-progress@^1.1.7 @radix-ui/react-radio-group@^1.3.7 \
  @radix-ui/react-scroll-area@^1.2.9 @radix-ui/react-select@^2.2.5 \
  @radix-ui/react-separator@^1.1.7 @radix-ui/react-slider@^1.3.5 \
  @radix-ui/react-slot@^1.2.3 @radix-ui/react-switch@^1.2.5 \
  @radix-ui/react-tabs@^1.1.12 @radix-ui/react-toast@^1.2.14 \
  @radix-ui/react-toggle@^1.1.9 @radix-ui/react-toggle-group@^1.1.10 \
  @radix-ui/react-tooltip@^1.2.7 cmdk@^1.1.1 embla-carousel-react@^8.6.0 \
  input-otp@^1.4.2 react-day-picker@^8.10.1 react-resizable-panels@^2.1.9 \
  vaul@^0.9.9 next-themes@^0.3.0

# 3) Install dev dependencies
npm install -D @vitejs/plugin-react-swc@^3.11.0 \
  tailwindcss@^3.4.17 @tailwindcss/typography@^0.5.16 \
  postcss@^8.5.6 autoprefixer@^10.4.21

# 4) Initialize shadcn/ui
npx shadcn@latest init -d

# 5) Add ALL shadcn components (complete UI library)
npx shadcn@latest add button input card toast dialog select tabs accordion \
  alert-dialog avatar checkbox collapsible dropdown-menu hover-card label \
  menubar navigation-menu popover progress radio-group scroll-area separator \
  slider switch toggle tooltip aspect-ratio breadcrumb calendar carousel \
  command context-menu drawer form input-otp pagination resizable sheet \
  skeleton table textarea toggle-group

# 6) Setup environment
cp .env.example .env  # then fill API endpoint values

# 7) Run
npm run dev
```

## Complete Shadcn/UI Component Setup

### Why Install All Components Upfront?

Based on the itinerary-orchestra project pattern, we install ALL shadcn/ui components from the start because:

- **Consistency**: Every project has the same component library available
- **Productivity**: No need to stop development to install missing components
- **Design System**: Ensures consistent UI patterns across all projects
- **Future-Proof**: Components are ready when features are added

### Complete Component List

The boilerplate includes these shadcn/ui components:

**Core Components:**
- `button`, `input`, `card`, `toast`, `dialog`, `select`, `tabs`

**Layout Components:**
- `accordion`, `collapsible`, `separator`, `aspect-ratio`, `resizable`

**Navigation Components:**
- `menubar`, `navigation-menu`, `breadcrumb`, `pagination`

**Form Components:**
- `checkbox`, `radio-group`, `switch`, `toggle`, `toggle-group`, `slider`, `form`, `input-otp`

**Overlay Components:**
- `alert-dialog`, `popover`, `hover-card`, `dropdown-menu`, `context-menu`, `sheet`, `drawer`

**Data Display:**
- `table`, `calendar`, `carousel`, `avatar`, `skeleton`, `progress`

**Interactive Components:**
- `command`, `scroll-area`, `label`, `tooltip`, `textarea`

### Component Import Pattern

All components use the `@/` path alias system:

```tsx
// Import any component from the complete library
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Dialog } from "@/components/ui/dialog";
import { Select } from "@/components/ui/select";
// ... and 40+ more components available
```

### Path Aliases Configuration

The `components.json` configuration matches itinerary-orchestra:

```json
{
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
```

This ensures consistent imports across all projects and matches the proven pattern from itinerary-orchestra.

## Tailwind v3 Setup

‚ö†Ô∏è **IMPORTANT:** Tailwind v3 uses traditional configuration with `tailwind.config.js`

### 1. Vite Configuration (`vite.config.ts`)
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

### 2. Tailwind Configuration (`tailwind.config.js`)
```js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Define your color system based on Design_reference.md
        // Use CSS custom properties for theme consistency
        primary: {
          DEFAULT: 'rgb(var(--primary))',
          foreground: 'rgb(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'rgb(var(--secondary))',
          foreground: 'rgb(var(--secondary-foreground))',
        },
        background: 'rgb(var(--background))',
        foreground: 'rgb(var(--foreground))',
        card: {
          DEFAULT: 'rgb(var(--card))',
          foreground: 'rgb(var(--card-foreground))',
        },
        border: 'rgb(var(--border))',
        input: 'rgb(var(--input))',
        ring: 'rgb(var(--ring))',
        // Add more colors as specified in Design_reference.md
      },
      fontFamily: {
        // Define fonts based on Design_reference.md
        sans: ['Inter', 'sans-serif'],
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      animation: {
        'fade-in': 'fadeIn 0.4s ease-out',
        'fade-in-up': 'fadeInUp 0.4s ease-out',
        'fade-in-down': 'fadeInDown 0.4s ease-out',
        'slide-in-left': 'slideInLeft 0.3s ease-out',
        'slide-in-right': 'slideInRight 0.3s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
        'bounce-in': 'bounceIn 0.6s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        fadeInDown: {
          '0%': { opacity: '0', transform: 'translateY(-20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        slideInLeft: {
          '0%': { opacity: '0', transform: 'translateX(-20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        slideInRight: {
          '0%': { opacity: '0', transform: 'translateX(20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        scaleIn: {
          '0%': { opacity: '0', transform: 'scale(0.9)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
        bounceIn: {
          '0%': { opacity: '0', transform: 'scale(0.3)' },
          '50%': { opacity: '1', transform: 'scale(1.05)' },
          '70%': { transform: 'scale(0.9)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
      },
      // Add custom shadows, spacing, etc. based on Design_reference.md
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography"),
  ],
}
```

### 3. PostCSS Configuration (`postcss.config.js`)
```js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

### 4. CSS Setup with Design System (`src/index.css`)

**IMPORTANT:** Define your color system based on `Design_reference.md` specifications.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Import fonts as specified in Design_reference.md */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

/* Design System with CSS Custom Properties */
@layer base {
  :root {
    /* Define your color palette based on Design_reference.md */
    /* Use RGB format for consistency: --color-name: R G B; */
    /* RGB values without rgb() wrapper - space-separated */
    
    --background: 255 255 255;
    --foreground: 30 41 59;
    
    --primary: 59 130 246;
    --primary-foreground: 255 255 255;
    
    --secondary: 100 116 139;
    --secondary-foreground: 255 255 255;
    
    --card: 255 255 255;
    --card-foreground: 30 41 59;
    
    --border: 226 232 240;
    --input: 226 232 240;
    --ring: 59 130 246;
    
    /* Add more variables as needed from Design_reference.md */
    
    --radius: 0.5rem; /* Adjust based on design */
  }
}

@layer base {
  * {
    @apply border-border;
  }
  
  body {
    @apply bg-background text-foreground font-sans;
    /* Apply typography from Design_reference.md */
  }
  
  /* Configure heading styles based on Design_reference.md */
  h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: 1.2;
  }
}

@layer components {
  /* Add custom component classes based on Design_reference.md */
  /* Example: .btn-primary, .card-hover, etc. */
}

/* Smooth Scrolling */
@media (prefers-reduced-motion: no-preference) {
  html {
    scroll-behavior: smooth;
  }
}

/* Custom Animations */
@keyframes accordion-down {
  from { height: 0; }
  to { height: var(--radix-accordion-content-height); }
}

@keyframes accordion-up {
  from { height: var(--radix-accordion-content-height); }
  to { height: 0; }
}

/* Focus Visible for Accessibility */
:focus-visible {
  outline: 2px solid rgb(var(--ring));
  outline-offset: 2px;
}
```

**Note:** All color values, typography, spacing, and design tokens should be extracted from `Design_reference.md` and implemented in your CSS custom properties.

## API Layer with Native Fetch

Simple, lightweight API utilities using native fetch():

### Fetch-based API Utilities (`src/lib/api.ts`)
```ts
// Simple fetch wrapper with error handling
async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${import.meta.env.VITE_API_URL || 'http://localhost:3000/api'}${endpoint}`;
  
  const config: RequestInit = {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    ...options,
  };

  // Add auth token if available
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${token}`,
    };
  }

  const response = await fetch(url, config);

  if (!response.ok) {
    if (response.status === 401) {
      localStorage.removeItem('auth_token');
      window.location.href = '/login';
    }
    throw new Error(`API Error: ${response.status}`);
  }

  return response.json();
}

// API utilities
export const api = {
  get: <T>(endpoint: string) => apiRequest<T>(endpoint),
  post: <T>(endpoint: string, data: unknown) => 
    apiRequest<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    }),
  put: <T>(endpoint: string, data: unknown) => 
    apiRequest<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    }),
  delete: (endpoint: string) => 
    apiRequest(endpoint, { method: 'DELETE' }),
};
```

### Resource API Example
```ts
// src/hooks/useProjects.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import type { Project, CreateProjectInput } from '@/types/project';

export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: () => api.get<Project[]>('/projects'),
  });
}

export function useProject(id: string) {
  return useQuery({
    queryKey: ['projects', id],
    queryFn: () => api.get<Project>(`/projects/${id}`),
    enabled: !!id,
  });
}

export function useCreateProject() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (project: CreateProjectInput) => 
      api.post<Project>('/projects', project),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['projects'] });
    },
  });
}
```

**When Supabase is used:** Also use the Supabase client for DB/Auth/Realtime/Storage; use Edge Functions or your backend for LLM calls and any logic that requires secrets (never expose API keys in the client).

## Supabase and Edge Functions

When Supabase is configured (e.g. `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` in `.env.local`):

### When to use what

- **Supabase client** (browser): Auth, database CRUD (with RLS), Realtime subscriptions, Storage uploads/downloads.
- **Edge Functions**: LLM calls, third-party APIs that need secrets, webhooks, cron jobs, or any server-only logic. Never put API keys in the client.

### Client setup

```ts
// src/lib/supabase.ts (or src/integrations/supabase/client.ts)
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true },
});
```

### Calling Edge Functions from the app

```ts
// Invoke an Edge Function (e.g. LLM proxy, webhook handler)
const { data, error } = await supabase.functions.invoke('my-function', {
  body: { key: 'value' },
});
if (error) throw error;
```

Create Edge Functions with `supabase functions new <name>`. Implement in `supabase/functions/<name>/index.ts` (Deno). Use `Deno.env.get('SUPABASE_URL')` and secrets for API keys; never expose keys to the client.

## LLM and AI (via Edge / backend)

- **Rule:** All LLM calls (OpenAI, Anthropic, etc.) go through a backend or Supabase Edge Function. Never expose LLM or third-party API keys in the client.
- **Recommended:** Use official SDKs (e.g. `openai`, `@anthropic-ai/sdk`) inside Edge Functions; store keys in Supabase secrets or env.
- **Pattern:** Client calls `supabase.functions.invoke('llm-proxy', { body: { messages, model?, stream? } })`; Edge validates input, calls the provider, returns JSON or streams.

### Minimal Edge LLM proxy (non-streaming)

```ts
// supabase/functions/llm-proxy/index.ts (Deno)
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';

serve(async (req) => {
  const { messages, model = 'gpt-4o-mini' } = await req.json();
  const apiKey = Deno.env.get('OPENAI_API_KEY');
  if (!apiKey) return new Response('Missing OPENAI_API_KEY', { status: 500 });
  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${apiKey}` },
    body: JSON.stringify({ model, messages }),
  });
  const data = await res.json();
  return new Response(JSON.stringify(data), { headers: { 'Content-Type': 'application/json' } });
});
```

For streaming, return a `ReadableStream` from the Edge Function and consume it in the client (e.g. with a hook that updates React state as chunks arrive).

### Performance

- Use Edge Functions for heavy or server-only work so the client stays fast.
- Use streaming for LLM responses when you need incremental UI updates.
- Keep React Query defaults (e.g. staleTime, gcTime) as in the boilerplate for predictable caching.

## Environment Configuration
**.env**
```ini
VITE_API_URL=http://localhost:3000/api
```

**.env.example**
```ini
# API Configuration
VITE_API_URL=http://localhost:3000/api

# Add your backend API URL here
# For production, use your deployed API endpoint
```

## Providers in `App.tsx`
Wrap the app with Router, QueryClient, and Toaster.
```tsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toast";
import Home from "@/pages/Home";
import ProjectDetails from "@/pages/ProjectDetails";
import NotFound from "@/pages/NotFound";

// React Query client with optimal defaults
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 10, // 10 minutes (formerly cacheTime)
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/project/:id" element={<ProjectDetails />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </BrowserRouter>
      <Toaster />
    </QueryClientProvider>
  );
}
```

## Tailwind CSS Animations

### Enhanced Tailwind Configuration with Custom Animations
```js
// tailwind.config.js - Add to theme.extend
module.exports = {
  theme: {
    extend: {
      animation: {
        'fade-in': 'fadeIn 0.4s ease-out',
        'fade-in-up': 'fadeInUp 0.4s ease-out',
        'fade-in-down': 'fadeInDown 0.4s ease-out',
        'slide-in-left': 'slideInLeft 0.3s ease-out',
        'slide-in-right': 'slideInRight 0.3s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
        'bounce-in': 'bounceIn 0.6s ease-out',
        'stagger': 'fadeInUp 0.4s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        fadeInDown: {
          '0%': { opacity: '0', transform: 'translateY(-20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        slideInLeft: {
          '0%': { opacity: '0', transform: 'translateX(-20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        slideInRight: {
          '0%': { opacity: '0', transform: 'translateX(20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        scaleIn: {
          '0%': { opacity: '0', transform: 'scale(0.9)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
        bounceIn: {
          '0%': { opacity: '0', transform: 'scale(0.3)' },
          '50%': { opacity: '1', transform: 'scale(1.05)' },
          '70%': { transform: 'scale(0.9)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```

### Page Transitions with CSS
```tsx
// src/components/AnimatedPage.tsx
import { ReactNode } from "react";
import { cn } from "@/lib/utils";

interface AnimatedPageProps {
  children: ReactNode;
  className?: string;
}

export function AnimatedPage({ children, className }: AnimatedPageProps) {
  return (
    <div className={cn("animate-fade-in-up", className)}>
      {children}
    </div>
  );
}
```

### Staggered List Animations
```tsx
// src/components/AnimatedList.tsx
import { ReactNode } from "react";
import { cn } from "@/lib/utils";

export function AnimatedList({ children }: { children: ReactNode }) {
  return (
    <div className="space-y-2">
      {children}
    </div>
  );
}

export function AnimatedListItem({ 
  children, 
  delay = 0 
}: { 
  children: ReactNode;
  delay?: number;
}) {
  return (
    <div 
      className="animate-fade-in-up"
      style={{ animationDelay: `${delay * 100}ms` }}
    >
      {children}
    </div>
  );
}
```

### Interactive Button Animations
```tsx
// Example usage with hover and active states
<button className="bg-primary text-white px-6 py-3 rounded-lg transition-all duration-200 hover:scale-105 hover:shadow-lg active:scale-95 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2">
  Click Me
</button>
```

## Recharts Integration

### Basic Chart Component
```tsx
// src/components/charts/AnalyticsChart.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts";

interface ChartData {
  name: string;
  value: number;
}

interface AnalyticsChartProps {
  data: ChartData[];
  title: string;
}

export function AnalyticsChart({ data, title }: AnalyticsChartProps) {
  return (
    <Card className="animate-fade-in-up">
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip />
            <Line 
              type="monotone" 
              dataKey="value" 
              stroke="rgb(var(--primary))" 
              strokeWidth={2}
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}
```

### Dashboard with Multiple Charts
```tsx
// src/components/charts/Dashboard.tsx
import { AnalyticsChart } from "./AnalyticsChart";
import { BarChart, Bar, PieChart, Pie, Cell } from "recharts";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

const COLORS = ['rgb(var(--primary))', 'rgb(var(--secondary))', '#8884d8', '#82ca9d'];

export function Dashboard() {
  const lineData = [
    { name: 'Jan', value: 400 },
    { name: 'Feb', value: 300 },
    { name: 'Mar', value: 600 },
    { name: 'Apr', value: 800 },
  ];

  const pieData = [
    { name: 'Group A', value: 400 },
    { name: 'Group B', value: 300 },
    { name: 'Group C', value: 300 },
    { name: 'Group D', value: 200 },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 p-6">
      <AnalyticsChart data={lineData} title="Monthly Analytics" />
      
      <Card className="animate-fade-in-up">
        <CardHeader>
          <CardTitle>Distribution</CardTitle>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={pieData}
                cx="50%"
                cy="50%"
                outerRadius={80}
                fill="#8884d8"
                dataKey="value"
              >
                {pieData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    </div>
  );
}
```

## Typography Plugin Usage

### Rich Text Content
```tsx
// src/components/RichContent.tsx
import { Card } from "@/components/ui/card";

export function RichContent({ content }: { content: string }) {
  return (
    <Card className="p-6">
      <div 
        className="prose prose-slate max-w-none"
        dangerouslySetInnerHTML={{ __html: content }}
      />
    </Card>
  );
}
```

### Blog Post Component
```tsx
// src/components/BlogPost.tsx
import { Card, CardContent, CardHeader } from "@/components/ui/card";

interface BlogPostProps {
  title: string;
  content: string;
  author: string;
  date: string;
}

export function BlogPost({ title, content, author, date }: BlogPostProps) {
  return (
    <article className="animate-fade-in-up">
      <Card>
        <CardHeader>
          <h1 className="text-3xl font-bold">{title}</h1>
          <div className="text-muted-foreground">
            By {author} ‚Ä¢ {date}
          </div>
        </CardHeader>
        <CardContent>
          <div className="prose prose-lg prose-slate max-w-none">
            {content.split('\n').map((paragraph, index) => (
              <p key={index}>{paragraph}</p>
            ))}
          </div>
        </CardContent>
      </Card>
    </article>
  );
}
```

## Useful Patterns

### 1. `cn()` Utility (`src/lib/utils.ts`)
```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

### 2. Custom Hooks Organization
- **Domain models:** `src/types/*`
- **Feature sections:** `src/components/home/*`, `src/components/charts/*`
- **Data hooks:** `src/hooks/useProjects.ts` using React Query + native fetch
- **API utilities:** `src/lib/api.ts`

### 3. Modern Component Pattern with Tailwind Animations
```tsx
// src/components/ProjectCard.tsx
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { FileText, Calendar } from "lucide-react";
import { cn } from "@/lib/utils";

interface ProjectCardProps {
  title: string;
  description: string;
  date: string;
  className?: string;
}

export function ProjectCard({ title, description, date, className }: ProjectCardProps) {
  return (
    <div className="group animate-fade-in-up">
      <Card className={cn(
        "p-6 transition-all duration-300 hover:-translate-y-1 hover:shadow-lg",
        className
      )}>
        <div className="flex items-start gap-4">
          <div className="rounded-lg bg-primary/10 p-3 transition-colors group-hover:bg-primary/20">
            <FileText className="h-6 w-6 text-primary" />
          </div>
          <div className="flex-1">
            <h3 className="font-semibold text-lg transition-colors group-hover:text-primary">
              {title}
            </h3>
            <p className="text-muted-foreground mt-1">{description}</p>
            <div className="flex items-center gap-2 mt-3 text-sm text-muted-foreground">
              <Calendar className="h-4 w-4" />
              <span>{date}</span>
            </div>
          </div>
        </div>
        <Button 
          variant="outline" 
          className="w-full mt-4 transition-all hover:scale-[1.02]"
        >
          View Details
        </Button>
      </Card>
    </div>
  );
}
```

### 4. Enhanced Button Component
```tsx
// src/components/ui/animated-button.tsx
import { Button, type ButtonProps } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export function AnimatedButton({ className, ...props }: ButtonProps) {
  return (
    <Button
      className={cn(
        "transition-all duration-200 hover:scale-105 hover:shadow-lg active:scale-95",
        className
      )}
      {...props}
    />
  );
}
```

### 5. Sonner Toast Integration
```tsx
// Use Sonner for toast notifications
import { toast } from "sonner";
import { Toaster } from "sonner";

// In your App.tsx
function App() {
  return (
    <div>
      {/* Your app content */}
      <Toaster />
    </div>
  );
}

// Usage in components
function MyComponent() {
  const handleSuccess = () => {
    toast.success("Project created successfully!");
  };
  
  const handleError = () => {
    toast.error("Failed to create project");
  };
  
  const handleLoading = () => {
    const toastId = toast.loading("Creating project...");
    // Later...
    toast.success("Project created!", { id: toastId });
  };
}
```

---

## Best Practices Checklist

### ‚úÖ Styling & Design
- [x] Tailwind v3 with comprehensive CSS custom properties
- [x] Inter font loaded via Google Fonts
- [x] Shadcn/ui components for consistent design system
- [x] Tailwind CSS animations with custom keyframes
- [x] Typography plugin for rich text content
- [x] Lucide React for modern icons
- [x] Base styles with proper reset and typography
- [x] Enhanced design system with RGB color values
- [x] Responsive design with mobile-first approach
- [x] Accessibility with focus-visible styles

### ‚úÖ Performance
- [x] React Query with optimal cache settings
- [x] Code splitting with dynamic imports
- [x] Optimized CSS animations with hardware acceleration
- [x] Native fetch() for lightweight HTTP requests
- [x] Proper image optimization (WebP, lazy loading)
- [x] Tree-shaking enabled in Vite
- [x] SWC for faster builds

### ‚úÖ Developer Experience
- [x] TypeScript strict mode
- [x] ESLint configured
- [x] Path aliases (`@/*`)
- [x] Environment variables with type safety
- [x] Lightweight fetch-based API utilities
- [x] Recharts for data visualization
- [x] Typography plugin for rich content

### ‚úÖ Architecture
- [x] Feature-based folder structure
- [x] Separation of concerns (components, hooks, utils, charts)
- [x] Lightweight API utilities in `src/lib/api.ts`
- [x] Schema validation with Zod
- [x] Error boundaries
- [x] Streamlined for rapid prototyping

---

## Important Notes

‚ö†Ô∏è **Critical Setup Requirements:**

1. **Tailwind v3 Config** - Use `tailwind.config.js` with CSS custom properties and Typography plugin
2. **Font Import** - Always include Inter font in CSS for consistent typography
3. **Vite SWC** - Use `@vitejs/plugin-react-swc` for faster builds
4. **Shadcn Init** - Run `npx shadcn@latest init -d` to setup components properly
5. **Base Styles** - Include body, root, and reset styles in `index.css`
6. **Custom Animations** - Add keyframes to Tailwind config for smooth transitions
7. **API Utilities** - Use lightweight fetch wrapper in `src/lib/api.ts`

üì¶ **Project Consistency:**
- Commit `ui/` (shadcn) components for consistency across projects
- Keep `.env.example` updated so onboarding is trivial
- Prefer typed APIs and schema validation with `zod` for reliability
- Use Tailwind CSS animations for all interactive elements and page transitions
- Always use `lucide-react` icons for consistency
- Use Sonner for toast notifications
- Use Recharts for data visualization
- Use native fetch() with lightweight API utilities
- Typography plugin for rich text content

üé® **Beautiful UI Requirements:**
- Modern card-based layouts with shadows and rounded corners
- Smooth page transitions with Tailwind CSS animations
- Hover states on interactive elements
- Loading states with skeleton loaders
- Toast notifications with Sonner
- Data visualization with Recharts
- Rich typography with Typography plugin
- Comprehensive design system with RGB colors


=== QUICK REFERENCE GUIDE ===
# Modern React Stack - Quick Reference

## üéØ The Golden Rules

1. **USE `tailwind.config.js`** - Tailwind v3 with CSS custom properties
2. **ALWAYS import Inter font** in `src/index.css`
3. **ALWAYS use Tailwind CSS animations** with custom keyframes (NOT Motion library or framer-motion)
4. **ALWAYS use Shadcn components** instead of custom
5. **ALWAYS use Lucide icons**
6. **ALWAYS use Sonner** for toast notifications
7. **ALWAYS set up Vitest** for testing
8. **API layer:** Use native `fetch()` with the API utilities in `src/lib/api.ts` (see REACT_BOILERPLATE)
9. **When using Supabase:** Use the client for DB/Auth/Realtime/Storage; use Edge Functions for server-only logic and LLM. Invoke with `supabase.functions.invoke('function-name', { body })`.
10. **LLM / AI:** Never expose LLM API keys in the client. Call an Edge Function or backend: `supabase.functions.invoke('llm-proxy', { body: { messages } })`.

---

## üöÄ Quick Setup

```bash
# 1. Create project
npm create vite@latest my-app -- --template react-ts
cd my-app

# 2. Install everything (native fetch - no axios; Tailwind animations - no Motion)
npm install react@^18.3.1 react-dom@^18.3.1 react-router-dom@^6.30.1 \
  @tanstack/react-query@^5.83.0 \
  react-hook-form@^7.61.1 @hookform/resolvers@^3.10.0 zod@^3.25.76 \
  clsx@^2.1.1 class-variance-authority@^0.7.1 tailwind-merge@^2.6.0 \
  tailwindcss-animate@^1.0.7 lucide-react@^0.462.0 \
  sonner@^1.7.4 date-fns@^3.6.0 recharts@^2.15.4 \
  @radix-ui/react-slot@^1.2.3 @radix-ui/react-dropdown-menu@^2.1.15 \
  @radix-ui/react-toast@^1.2.14 @radix-ui/react-dialog@^1.1.14 \
  @radix-ui/react-select@^2.2.5 @radix-ui/react-tabs@^1.1.12 \
  @radix-ui/react-avatar@^1.1.10 @radix-ui/react-label@^2.1.7

# Optional when using Supabase: npm install @supabase/supabase-js

npm install -D vitest@^3.2.4 @testing-library/react@^16.3.0 \
  @testing-library/jest-dom@^6.7.0 @testing-library/user-event@^14.6.1 \
  jsdom@^26.1.0 @vitejs/plugin-react-swc@^3.11.0 \
  tailwindcss@^3.4.17 @tailwindcss/typography@^0.5.16 postcss@^8.5.6 autoprefixer@^10.4.21

# 3. Setup Shadcn
npx shadcn@latest init -d
npx shadcn@latest add button input card toast
```

---

## üìù Essential Files

### `vite.config.ts`
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

### `tailwind.config.js`
```js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Define colors based on Design_reference.md
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        // Add more colors from Design_reference.md
      },
      fontFamily: {
        // Define fonts from Design_reference.md
        sans: ['Inter', 'sans-serif'],
      },
      borderRadius: {
        lg: 'var(--radius)',
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```

### `src/index.css` (Setup)
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Import fonts from Design_reference.md */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

@layer base {
  :root {
    /* Define CSS variables based on Design_reference.md */
    /* Use HSL format: --color-name: H S% L%; */
    --background: /* from Design_reference.md */;
    --foreground: /* from Design_reference.md */;
    --primary: /* from Design_reference.md */;
    /* Add all design system variables here */
    --radius: 0.5rem; /* from Design_reference.md */
  }
  
  .dark {
    /* Dark mode colors if specified in Design_reference.md */
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground font-sans;
  }
}
```

---

## üé® Component Patterns

### Animated Page (Tailwind CSS animations)
```tsx
import { cn } from "@/lib/utils";

export function AnimatedPage({ children, className }) {
  return (
    <div className={cn("animate-fade-in-up", className)}>
      {children}
    </div>
  );
}
```

### Button with hover (Tailwind)
```tsx
import { Button } from "@/components/ui/button";

export function AnimatedButton(props) {
  return (
    <Button
      className="transition-all duration-200 hover:scale-[1.02] active:scale-[0.98]"
      {...props}
    />
  );
}
```

### Card with Icon
```tsx
import { Card } from "@/components/ui/card";
import { FileText } from "lucide-react";
import { cn } from "@/lib/utils";

export function ProjectCard({ title, description, className }) {
  return (
    <Card className={cn("p-6 transition-all hover:-translate-y-0.5 hover:shadow-lg animate-fade-in-up", className)}>
      <div className="flex gap-4">
        <div className="rounded-lg bg-primary/10 p-3">
          <FileText className="h-6 w-6 text-primary" />
        </div>
        <div>
          <h3 className="font-semibold">{title}</h3>
          <p className="text-muted-foreground">{description}</p>
        </div>
      </div>
    </Card>
  );
}
```

---

## üîß Utilities

### `src/lib/utils.ts`
```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

---

## üì± Common Animations

### Stagger List
```tsx
const container = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { staggerChildren: 0.1 }
  }
};

const item = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0 }
};

<motion.div variants={container} initial="hidden" animate="visible">
  {items.map(item => (
    <motion.div key={item.id} variants={item}>
      {item.content}
    </motion.div>
  ))}
</motion.div>
```

### Fade In
```tsx
<motion.div
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
  transition={{ duration: 0.5 }}
/>
```

### Slide Up
```tsx
<motion.div
  initial={{ y: 50, opacity: 0 }}
  animate={{ y: 0, opacity: 1 }}
  transition={{ type: "spring", stiffness: 100 }}
/>
```

## üß™ Testing Quick Reference

### Run Tests
```bash
npm test              # Run tests in watch mode
npm run test:ui       # Run with UI
npm run test:coverage # Generate coverage report
```

### Basic Component Test
```tsx
import { render, screen } from '@testing-library/react';
import { Button } from '@/components/ui/button';

test('renders button', () => {
  render(<Button>Click me</Button>);
  expect(screen.getByText('Click me')).toBeInTheDocument();
});
```

### API Layer Pattern (native fetch)
```tsx
// Use src/lib/api.ts (api.get, api.post, etc.) - see REACT_BOILERPLATE
import { api } from '@/lib/api';

export const projectsApi = {
  getAll: async () => api.get('/projects'),
};
```

---

## üéØ Design System Reference

**IMPORTANT:** All design decisions (colors, typography, spacing, shadows) must come from `Design_reference.md` in your project root.

```css
@layer base {
  :root {
    /* Define design tokens based on Design_reference.md */
    /* Use HSL format for colors: --color-name: H S% L%; */
    
    /* Example structure - replace with actual values from Design_reference.md */
    --background: /* your value */;
    --foreground: /* your value */;
    --primary: /* your value */;
    --primary-foreground: /* your value */;
    
    /* Add shadows, transitions, spacing from Design_reference.md */
    --radius: /* your value */;
  }
}
```

**Always reference Design_reference.md before implementing any styling.**

---

## ‚úÖ Pre-Flight Checklist

Before starting any project:

- [ ] Vite configured with SWC plugin
- [ ] `tailwind.config.js` with CSS custom properties
- [ ] Inter font imported in CSS
- [ ] CSS custom properties in `src/index.css`
- [ ] Base styles (body, *, headings) defined
- [ ] Motion library installed (NOT framer-motion)
- [ ] Shadcn initialized
- [ ] Lucide React installed
- [ ] Sonner for toasts
- [ ] Vitest testing setup
- [ ] Path aliases configured (`@/*`)
- [ ] Axios API client setup
- [ ] API layer structure created

---

## üö® Common Mistakes to Avoid

‚ùå **DON'T:**
- Use Motion library or framer-motion (use Tailwind CSS animations)
- Expose LLM or third-party API keys in the client (use Edge Functions)
- Forget to import fonts
- Skip base styles
- Use plain buttons (use Shadcn)
- Use FontAwesome (use Lucide)
- Skip animations
- Skip testing setup
- Use Radix toast (use Sonner)

‚úÖ **DO:**
- Use Tailwind v3 with CSS custom properties and custom keyframes
- Import Inter font
- Include base styles
- Use Shadcn components
- Use Lucide icons
- Use Tailwind animation classes (animate-fade-in-up, etc.)
- Set up Vitest testing
- Use Sonner for toasts
- Use native fetch() in src/lib/api.ts for API layer
- Call LLM via supabase.functions.invoke or backend only

---

## üì¶ Package.json Essentials

```json
{
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.30.1",
    "motion": "^12.23.12",
    "lucide-react": "^0.462.0",
    "sonner": "^1.7.4",
    "@tanstack/react-query": "^5.83.0",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.6.0"
  },
  "devDependencies": {
    "vite": "^5.4.19",
    "tailwindcss": "^3.4.17",
    "vitest": "^3.2.4",
    "@testing-library/react": "^16.3.0",
    "@vitejs/plugin-react-swc": "^3.11.0",
    "typescript": "^5.8.3"
  }
}
```

---

## üé® Shadcn Components to Use

Essential:
```bash
npx shadcn@latest add button
npx shadcn@latest add card
npx shadcn@latest add input
npx shadcn@latest add toast
```

Recommended:
```bash
npx shadcn@latest add dialog
npx shadcn@latest add dropdown-menu
npx shadcn@latest add select
npx shadcn@latest add tabs
npx shadcn@latest add form
```

---

## üí° Pro Tips

1. **Wrap routes in AnimatedPage (Tailwind animate-fade-in-up)**
2. **Use Tailwind transition/hover classes on interactive elements**
3. **Stagger list items with animationDelay**
4. **Use Lucide icons with consistent sizing**
5. **Leverage CSS custom properties (RGB format in boilerplate)**
6. **Mobile-first with Tailwind**
7. **Dark mode via CSS variables**
8. **Use `cn()` for conditional classes**
9. **Use native fetch() in src/lib/api.ts for API layer**
10. **Use Sonner for better toast UX**
11. **Test components with Vitest**
12. **When using Supabase: Edge Functions for LLM and secrets; client for DB/Auth/Realtime**

---

**Save this file for quick reference! üìå**










=== API LAYER ARCHITECTURE ===
# API Layer Architecture Guide

## Overview
This guide covers the centralized API layer architecture for the modern React boilerplate. The API layer provides a clean separation between data fetching logic and UI components, making the codebase more maintainable and testable. **Canonical approach:** native `fetch()` via `src/lib/api.ts`. When Supabase is used, the client handles DB/Auth/Realtime/Storage, and Edge Functions act as the API for server-only logic (e.g. LLM, secrets).

## Architecture Principles

### 1. Centralized Data Fetching
- All API calls are centralized in the `src/api/` directory
- Each resource has its own API module (e.g., `projects.ts`, `users.ts`)
- Consistent error handling and response formatting
- Type-safe API functions with TypeScript

### 2. React Query Integration
- API functions are consumed by React Query hooks
- Automatic caching, background updates, and optimistic updates
- Built-in loading and error states
- Request deduplication and retry logic

### 3. Separation of Concerns
- API layer handles data fetching and transformation
- React Query hooks handle caching and state management
- Components focus on UI and user interactions
- Clear boundaries between layers

## File Structure

```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ api.ts            # Fetch-based API client (canonical)
‚îú‚îÄ‚îÄ api/                    # Centralized API functions
‚îÇ   ‚îú‚îÄ‚îÄ projects.ts        # Project-related API calls
‚îÇ   ‚îú‚îÄ‚îÄ users.ts          # User-related API calls
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts           # Authentication API calls
‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # Re-export all API functions
‚îú‚îÄ‚îÄ hooks/                 # React Query hooks
‚îÇ   ‚îú‚îÄ‚îÄ useProjects.ts    # Project-related hooks
‚îÇ   ‚îú‚îÄ‚îÄ useUsers.ts       # User-related hooks
‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts        # Authentication hooks
‚îî‚îÄ‚îÄ types/                 # TypeScript type definitions
    ‚îú‚îÄ‚îÄ api.ts            # API response types
    ‚îú‚îÄ‚îÄ project.ts        # Project types
    ‚îî‚îÄ‚îÄ user.ts           # User types
```

When using Supabase, add `src/lib/supabase.ts` (or `src/integrations/supabase/client.ts`) and call Edge Functions via `supabase.functions.invoke()`.

## API Layer Implementation

### 1. API Client Configuration (`src/lib/api.ts`) ‚Äì preferred

Use native `fetch()` with a thin wrapper. No axios dependency.

```ts
async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const base = import.meta.env.VITE_API_URL || 'http://localhost:3000/api';
  const url = `${base}${endpoint}`;
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string>),
  };
  const token = localStorage.getItem('auth_token');
  if (token) (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`;

  const res = await fetch(url, { ...options, headers });
  if (!res.ok) {
    if (res.status === 401) {
      localStorage.removeItem('auth_token');
      window.location.href = '/login';
    }
    throw new Error(`API Error: ${res.status}`);
  }
  return res.json();
}

export const api = {
  get: <T>(endpoint: string) => apiRequest<T>(endpoint),
  post: <T>(endpoint: string, data: unknown) =>
    apiRequest<T>(endpoint, { method: 'POST', body: JSON.stringify(data) }),
  put: <T>(endpoint: string, data: unknown) =>
    apiRequest<T>(endpoint, { method: 'PUT', body: JSON.stringify(data) }),
  patch: <T>(endpoint: string, data: unknown) =>
    apiRequest<T>(endpoint, { method: 'PATCH', body: JSON.stringify(data) }),
  delete: <T>(endpoint: string) => apiRequest<T>(endpoint, { method: 'DELETE' }),
};

export interface ApiResponse<T> {
  data: T | null;
  error: string | null;
}

export interface PaginatedResponse<T> {
  data: T[];
  count: number;
  page: number;
  limit: number;
}

export class ApiError extends Error {
  constructor(
    message: string,
    public status?: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
```

### 2. Projects API (`src/api/projects.ts`)
```ts
import { api } from '@/lib/api';
import type { Project, CreateProjectInput, UpdateProjectInput } from '@/types/project';

export const projectsApi = {
  getAll: async (): Promise<Project[]> =>
    api.get<Project[]>('/projects'),

  getById: async (id: string): Promise<Project> =>
    api.get<Project>(`/projects/${id}`),

  create: async (project: CreateProjectInput): Promise<Project> =>
    api.post<Project>('/projects', project),

  update: async (id: string, updates: UpdateProjectInput): Promise<Project> =>
    api.put<Project>(`/projects/${id}`, updates),

  patch: async (id: string, updates: Partial<UpdateProjectInput>): Promise<Project> =>
    api.patch<Project>(`/projects/${id}`, updates),

  delete: async (id: string): Promise<void> =>
    api.delete(`/projects/${id}`),

  getByUserId: async (userId: string): Promise<Project[]> =>
    api.get<Project[]>(`/projects/user/${userId}`),

  search: async (query: string): Promise<Project[]> =>
    api.get<Project[]>(`/projects/search?q=${encodeURIComponent(query)}`),
};
```

### 3. Users API (`src/api/users.ts`)
```ts
import { api } from '@/lib/api';
import type { User, UpdateUserInput } from '@/types/user';

export const usersApi = {
  getCurrent: async (): Promise<User> =>
    api.get<User>('/users/me'),

  updateProfile: async (updates: UpdateUserInput): Promise<User> =>
    api.put<User>(`/users/${updates.id}`, updates),

  getById: async (id: string): Promise<User> =>
    api.get<User>(`/users/${id}`),

  getAll: async (): Promise<User[]> =>
    api.get<User[]>('/users'),

  delete: async (id: string): Promise<void> =>
    api.delete(`/users/${id}`),
};
```

### 4. Authentication API (`src/api/auth.ts`)
```ts
import { api } from '@/lib/api';
import type { AuthResponse, SignInInput, SignUpInput } from '@/types/auth';

export const authApi = {
  signIn: async (credentials: SignInInput): Promise<AuthResponse> => {
    const data = await api.post<AuthResponse>('/auth/login', credentials);
    if (data.token) localStorage.setItem('auth_token', data.token);
    return data;
  },

  signUp: async (credentials: SignUpInput): Promise<AuthResponse> => {
    const data = await api.post<AuthResponse>('/auth/register', credentials);
    if (data.token) localStorage.setItem('auth_token', data.token);
    return data;
  },

  signOut: async (): Promise<void> => {
    await api.post('/auth/logout', {});
    localStorage.removeItem('auth_token');
  },

  resetPassword: async (email: string): Promise<void> =>
    api.post('/auth/forgot-password', { email }),

  updatePassword: async (token: string, newPassword: string): Promise<void> =>
    api.post('/auth/reset-password', { token, password: newPassword }),

  refreshToken: async (): Promise<AuthResponse> => {
    const data = await api.post<AuthResponse>('/auth/refresh', {});
    if (data.token) localStorage.setItem('auth_token', data.token);
    return data;
  },

  verifyEmail: async (token: string): Promise<void> =>
    api.post('/auth/verify-email', { token }),
};
```

## React Query Hooks

### 1. Projects Hooks (`src/hooks/useProjects.ts`)
```ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { projectsApi } from '@/api/projects';
import { toast } from 'sonner';
import type { Project, CreateProjectInput, UpdateProjectInput } from '@/types/project';

// Query keys
export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (filters: string) => [...projectKeys.lists(), { filters }] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (id: string) => [...projectKeys.details(), id] as const,
};

// Get all projects
export const useProjects = () => {
  return useQuery({
    queryKey: projectKeys.lists(),
    queryFn: projectsApi.getAll,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
};

// Get project by ID
export const useProject = (id: string) => {
  return useQuery({
    queryKey: projectKeys.detail(id),
    queryFn: () => projectsApi.getById(id),
    enabled: !!id,
  });
};

// Create project mutation
export const useCreateProject = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: projectsApi.create,
    onSuccess: (newProject) => {
      // Invalidate and refetch projects list
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      
      // Add the new project to the cache
      queryClient.setQueryData(projectKeys.detail(newProject.id), newProject);
      
      toast.success('Project created successfully!');
    },
    onError: (error) => {
      toast.error(`Failed to create project: ${error.message}`);
    },
  });
};

// Update project mutation
export const useUpdateProject = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, updates }: { id: string; updates: UpdateProjectInput }) =>
      projectsApi.update(id, updates),
    onSuccess: (updatedProject) => {
      // Update the project in the cache
      queryClient.setQueryData(projectKeys.detail(updatedProject.id), updatedProject);
      
      // Invalidate projects list to ensure consistency
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      
      toast.success('Project updated successfully!');
    },
    onError: (error) => {
      toast.error(`Failed to update project: ${error.message}`);
    },
  });
};

// Delete project mutation
export const useDeleteProject = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: projectsApi.delete,
    onSuccess: (_, deletedId) => {
      // Remove the project from the cache
      queryClient.removeQueries({ queryKey: projectKeys.detail(deletedId) });
      
      // Invalidate projects list
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
      
      toast.success('Project deleted successfully!');
    },
    onError: (error) => {
      toast.error(`Failed to delete project: ${error.message}`);
    },
  });
};
```

### 2. Authentication Hooks (`src/hooks/useAuth.ts`)
```ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { authApi } from '@/api/auth';
import { usersApi } from '@/api/users';
import { toast } from 'sonner';
import type { SignInInput, SignUpInput } from '@/types/auth';

// Query keys
export const authKeys = {
  user: ['auth', 'user'] as const,
};

// Get current user
export const useCurrentUser = () => {
  return useQuery({
    queryKey: authKeys.user,
    queryFn: usersApi.getCurrent,
    retry: false,
    staleTime: 1000 * 60 * 10, // 10 minutes
    enabled: !!localStorage.getItem('auth_token'), // Only fetch if token exists
  });
};

// Sign in mutation
export const useSignIn = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: authApi.signIn,
    onSuccess: (data) => {
      // Update the user in the cache
      if (data.user) {
        queryClient.setQueryData(authKeys.user, data.user);
      }
      
      toast.success('Signed in successfully!');
    },
    onError: (error: any) => {
      toast.error(`Sign in failed: ${error.response?.data?.message || error.message}`);
    },
  });
};

// Sign up mutation
export const useSignUp = () => {
  return useMutation({
    mutationFn: authApi.signUp,
    onSuccess: () => {
      toast.success('Account created! Please check your email to verify your account.');
    },
    onError: (error: any) => {
      toast.error(`Sign up failed: ${error.response?.data?.message || error.message}`);
    },
  });
};

// Sign out mutation
export const useSignOut = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: authApi.signOut,
    onSuccess: () => {
      // Clear all cached data
      queryClient.clear();
      
      toast.success('Signed out successfully!');
    },
    onError: (error: any) => {
      toast.error(`Sign out failed: ${error.response?.data?.message || error.message}`);
    },
  });
};

// Password reset mutation
export const usePasswordReset = () => {
  return useMutation({
    mutationFn: authApi.resetPassword,
    onSuccess: () => {
      toast.success('Password reset email sent! Check your inbox.');
    },
    onError: (error: any) => {
      toast.error(`Password reset failed: ${error.response?.data?.message || error.message}`);
    },
  });
};
```

## Type Definitions

### 1. API Types (`src/types/api.ts`)
```ts
export interface ApiResponse<T> {
  data: T | null;
  error: string | null;
}

export interface PaginatedResponse<T> {
  data: T[];
  count: number;
  page: number;
  limit: number;
}

export interface ApiError {
  message: string;
  status?: number;
  code?: string;
}
```

### 2. Project Types (`src/types/project.ts`)
```ts
export interface Project {
  id: string;
  name: string;
  description: string;
  user_id: string;
  created_at: string;
  updated_at: string;
}

export interface CreateProjectInput {
  name: string;
  description: string;
  user_id: string;
}

export interface UpdateProjectInput {
  id: string;
  name?: string;
  description?: string;
}
```

### 3. User Types (`src/types/user.ts`)
```ts
export interface User {
  id: string;
  email: string;
  full_name?: string;
  avatar_url?: string;
  created_at: string;
  updated_at: string;
}

export interface UpdateUserInput {
  id: string;
  full_name?: string;
  avatar_url?: string;
}
```

## Usage in Components

### 1. Using Query Hooks
```tsx
// src/components/ProjectList.tsx
import { useProjects } from '@/hooks/useProjects';
import { ProjectCard } from './ProjectCard';

export function ProjectList() {
  const { data: projects, isLoading, error } = useProjects();

  if (isLoading) {
    return <div>Loading projects...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div className="grid gap-4">
      {projects?.map((project) => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}
```

### 2. Using Mutation Hooks
```tsx
// src/components/CreateProjectForm.tsx
import { useCreateProject } from '@/hooks/useProjects';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const createProjectSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().min(1, 'Description is required'),
});

type CreateProjectForm = z.infer<typeof createProjectSchema>;

export function CreateProjectForm() {
  const createProject = useCreateProject();
  const { register, handleSubmit, formState: { errors } } = useForm<CreateProjectForm>({
    resolver: zodResolver(createProjectSchema),
  });

  const onSubmit = (data: CreateProjectForm) => {
    createProject.mutate({
      ...data,
      user_id: 'current-user-id', // Get from auth context
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('name')}
        placeholder="Project name"
        className="w-full p-2 border rounded"
      />
      {errors.name && <span className="text-red-500">{errors.name.message}</span>}

      <textarea
        {...register('description')}
        placeholder="Project description"
        className="w-full p-2 border rounded"
      />
      {errors.description && <span className="text-red-500">{errors.description.message}</span>}

      <button
        type="submit"
        disabled={createProject.isPending}
        className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
      >
        {createProject.isPending ? 'Creating...' : 'Create Project'}
      </button>
    </form>
  );
}
```

## API Layer with Supabase

When Supabase is configured, use two surfaces:

- **Supabase client** (`src/lib/supabase.ts`): Auth, database (with RLS), Realtime, Storage. Use the client directly in API modules or hooks for CRUD and subscriptions.
- **Edge Functions**: Server-only logic, LLM calls, third-party APIs with secrets. Invoke from the app with `supabase.functions.invoke()`.

File layout: keep `src/api/` for resource modules; add `src/lib/supabase.ts` and, for Edge, call `supabase.functions.invoke('function-name', { body })` from a dedicated API function or hook.

## Edge Functions as API

Treat Edge Functions as API endpoints: define typed request/response and call them from hooks.

```ts
// src/api/edge.ts
import { supabase } from '@/lib/supabase';

export const edgeApi = {
  invoke: async <TReq, TRes>(name: string, body: TReq): Promise<TRes> => {
    const { data, error } = await supabase.functions.invoke(name, { body });
    if (error) throw new Error(error.message);
    return data as TRes;
  },
};
```

Use in a hook with the same React Query and toast patterns (e.g. `useMutation`, `onError: (e) => toast.error(e.message)`). For streaming (e.g. LLM), consume the response stream in the hook and update state as chunks arrive.

## LLM and External APIs

- **Rule:** Never call LLM or third-party APIs with API keys from the client. Use an Edge Function (or app backend) as a proxy.
- **Pattern:** Create an Edge Function (e.g. `llm-proxy`) that accepts `{ messages, model?, stream? }`, calls OpenAI/Anthropic with a server-side API key, and returns JSON or a stream. Call it via `supabase.functions.invoke('llm-proxy', { body })` from a hook (e.g. `useLLM` or `useChat`).
- Use the same error handling and toasts as the rest of the API layer; map provider/rate-limit errors to user-facing messages.

## Best Practices

### 1. Error Handling
- Use consistent error handling across all API functions
- Provide meaningful error messages to users
- Log errors for debugging purposes
- Handle network errors gracefully

### 2. Caching Strategy
- Use appropriate stale times for different types of data
- Implement optimistic updates for better UX
- Invalidate related queries when data changes
- Use query keys consistently

### 3. Type Safety
- Define TypeScript interfaces for all API responses
- Use generic types for reusable API functions
- Validate API responses with runtime checks if needed
- Keep types in sync with backend schema
- Use generic types and API response types for type safety

### 4. Testing
- Mock API functions in tests
- Test error scenarios
- Verify query invalidation logic
- Test optimistic updates

This API layer architecture provides a solid foundation for data management in React applications, making the codebase more maintainable, testable, and user-friendly.


=== PROJECT REQUIREMENTS ===
# LifeOps ‚Äî Development Blueprint

## Project Concept
LifeOps is a modular, multi-agent AI operating system that automates projects, content, finances, and health through coordinated GPT-5‚Äìpowered agents. It provides a Master Dashboard and module dashboards (Projects, Content, Finance, Health), an orchestration layer for traceable agent-to-agent messages, scoped shared memory, conflict resolution rules, and a Cronjobs system treating scheduled autonomy as first-class objects. Each action is explainable, permissioned, schema-validated, logged, and reversible. The vision is an enterprise-grade, AI-native orchestration platform enabling safe, auditable, and configurable autonomous assistants for power users, teams, and orgs.

AI app description: Specialized agents per domain communicate through an ordered message bus and runtime abstraction. Cronjobs schedule or trigger agents/workflows with rich constraints, safety rails, and approval levels. The platform emphasizes explainability, reversibility, and full audit artifacts while integrating with external systems (VCS, CI/CD, CMS, banks, fitness trackers).

## Problem Statement
- Core problems:
  - Knowledge workers and teams spend repeated time on recurring operational tasks (triage PRs, monthly close, content pipelines, training plans).
  - Existing single-agent automations lack multi-agent coordination, traceability, and safe rollback.
  - Scheduled autonomy is often brittle or all-or-nothing without fine-grained controls and human-in-the-loop approvals.
  - Integrations across VCS, CI, finance, CMS and trackers are fragmented and hard to orchestrate with explainability and compliance.
- Who experiences these problems:
  - Individual founders, knowledge workers, content teams, finance managers, coaches/athletes, and org admins.
- Why these problems matter:
  - Time wasted, risky automated actions, lack of auditability, compliance exposure, and lost trust hinder adoption.
- Current state/gaps:
  - Tools either provide basic scheduling or heavy RPA but lack AI-native multi-agent orchestration, reversible actions, and first-class Cronjob objects with safety/approval controls.

## Solution
- How it addresses problems:
  - Multi-agent orchestration enables domain-specific agents to negotiate, handoff, and reach consensus with traceable messages and shared scoped memory.
  - Cronjobs as first-class objects provide safe scheduled autonomy with templated payloads, automation levels, constraints, retries and run artifacts.
  - Explainability and reversible actions (diffs, rollback scripts, schema validation) build trust and compliance.
  - Rich connectors and developer SDKs allow deep integration with VCS, CI, CMS, banks, trackers, and email/billing.
- Approach & methodology:
  - Modular architecture: agent runtime, message bus, cron engine, approvals layer, connectors/secret vault, UI frontends per module, REST/gRPC APIs, and SDKs.
  - Security & compliance-first: RBAC, audit logs, tamper-evident entries, encryption, and optional on-prem runners.
  - Progressive disclosure UX with templates and guided onboarding to reduce complexity.
- Key differentiators:
  - First-class Cronjobs with automation levels and full run artifacts.
  - Explainability stored alongside actions and schema-validated outputs enabling safe reversals.
  - Developer-centric project automation integrated with release orchestration and CI.
- Value creation:
  - Saves operational time, reduces human error, increases trust in automation, and unlocks new workflows through reusable templates and marketplace.

## Requirements

### 1. Pages (UI Screens)
List of pages with purpose, key components, and contribution:

- Landing Page (Public marketing)
  - Purpose: Communicate value, convert visitors to signups/demos.
  - Key sections: Hero, Feature Overview (Projects, Content, Finance, Health), Cronjobs & Approvals Snapshot, Use Cases, Pricing Teaser, Footer.
  - Contribution: Drives acquisition and explains first-class Cronjobs and agent benefits.

- Login / Signup
  - Purpose: Authentication entrypoint.
  - Key components: Email/password forms, SSO/Social buttons (Google, Microsoft, GitHub), password strength meter, TOS checkbox.
  - Contribution: Secure onboarding and SSO for enterprise users.

- Email Verification
  - Purpose: Confirm user ownership of email.
  - Key components: Verification message, resend button (rate limited), manual 6-digit code input.
  - Contribution: Security & account trust.

- Password Reset
  - Purpose: Secure recovery flow.
  - Key components: Request form, reset form with token validation, strength meter.
  - Contribution: Account safety and accessibility.

- Master Dashboard
  - Purpose: Single command center for system health and orchestration.
  - Key components: Top nav (search, avatar, org switch), System Overview cards, Cronjobs Timeline (list/calendar), Active Runs Feed, Alerts Panel, Audit Snapshot, Quick Create.
  - Contribution: Central monitoring and quick control for automation.

- Agent Directory
  - Purpose: Manage agents (system/user).
  - Key components: Filterable list, agent details (capabilities, memory scope, connectors), Create Agent Wizard, actions (clone/archive), message trace viewer.
  - Contribution: Visibility and lifecycle management for agents.

- Module Dashboard ‚Äî Projects
  - Purpose: Developer-centric automation (roadmaps, tickets, CI).
  - Key components: Project selector, Roadmap timeline, Ticket Board (Kanban with auto-triage), PR & Release pane, Integrations panel.
  - Contribution: Automates developer workflows and release orchestration.

- Module Dashboard ‚Äî Content
  - Purpose: End-to-end content pipeline automation.
  - Key components: Content calendar, Idea inbox (agent outlines), Editor workspace with suggestions and versioning, publishing connectors, analytics.
  - Contribution: Streamlines content creation and publishing.

- Module Dashboard ‚Äî Finance
  - Purpose: Automate bookkeeping, forecasting, anomalies.
  - Key components: Accounts overview, transactions feed with agent suggestions, subscriptions manager, forecasting & close workspace, export & audit.
  - Contribution: Reduce month-end effort and ensure traceable financial actions.

- Module Dashboard ‚Äî Health
  - Purpose: Automate habits, training plans, recovery balancing.
  - Key components: Habits & goals, training plans with calendar sync, nutrition planner, recovery/load insights, device integrations.
  - Contribution: Personalized coaching and automated planning.

- Cronjobs Manager
  - Purpose: CRUD and visualize Cronjobs as first-class objects.
  - Key components: Cronjob list (next run, last outcome), Cronjob details (payload, constraints, safety rails), Schedule builder UI, Create/Edit wizard, run controls.
  - Contribution: Safe scheduling and governance for automated workflows.

- Workflow Template Library
  - Purpose: Reusable multi-agent workflow templates.
  - Key components: Template catalog, template details, import & customize flow, rating & comments.
  - Contribution: Accelerates adoption with prebuilt workflows.

- Approvals Queue
  - Purpose: Human-in-the-loop reviews for pending actions.
  - Key components: Approvals list with SLA timers, approval details (diffs, artifacts), decision controls (approve/reject/modify), threaded comments.
  - Contribution: Safety and auditability for automation.

- Run Details & Artifacts
  - Purpose: Inspect single run with full artifacts and rollback.
  - Key components: Run summary, message trace viewer, action diffs (side-by-side), artifacts panel, rollback controls.
  - Contribution: Explainability and reversible actions.

- User Profile
  - Purpose: Manage personal settings and API keys.
  - Key components: Profile info, connections, API keys, agent presets, security (2FA).
  - Contribution: User-level control and developer access.

- Organization / Team Settings
  - Purpose: Manage teams, RBAC, billing, enterprise config.
  - Key components: Team roster, RBAC policies, billing, enterprise options (SAML, on‚Äëprem).
  - Contribution: Governance and enterprise controls.

- Settings & Preferences
  - Purpose: Global app settings and defaults.
  - Key components: Notification rules, automation defaults, data retention, developer settings.
  - Contribution: Platform customization and compliance.

- Admin Dashboard
  - Purpose: System admin controls and monitoring.
  - Key components: User management, system health, analytics, policy management.
  - Contribution: Operational reliability and policy enforcement.

- Integration Connectors
  - Purpose: Catalog and configure external connectors.
  - Key components: Connector catalog, setup wizard (OAuth/API key), secrets management, health panel.
  - Contribution: Enables workflow integrations.

- Docs & Help
  - Purpose: Documentation, tutorials, API docs.
  - Key components: Searchable docs, tutorials, support contact, changelog & status.
  - Contribution: Self-service enablement and onboarding.

- Privacy Policy, Terms of Service, Cookie Policy
  - Purpose: Legal and compliance pages.
  - Contribution: Regulatory and legal compliance.

- 404 Not Found / 500 Server Error
  - Purpose: User-friendly error handling.
  - Contribution: UX resilience and support guidance.

- Loading & Success States
  - Purpose: Standardized feedback components.
  - Contribution: Polished UX and clarity.

### 2. Features
Core features with technical details and implementation notes:

- User Authentication & Security
  - JWT access/refresh tokens, secure refresh flow.
  - OAuth2 (Google, Microsoft, GitHub), SAML for enterprise.
  - Password hashing with bcrypt/argon2, password policy enforcement.
  - Email verification with expiring tokens; TOTP 2FA with recovery codes.
  - Session management dashboard and revocation APIs.
  - Rate limiting & account lockout.

- Agent Orchestration Layer
  - Message bus (ordered, durable) with persistent traces (append-only store).
  - Agent runtime abstraction with pluggable skills/tools (connectors).
  - Scoped shared memory with ACLs, versioning and conflict resolution engine (rules: user constraints > safety > deadlines > ROI).
  - Explainability hooks (store rationales), schema validation for outputs, and audit logging.
  - APIs for agent registration, runtime telemetry, and tracing.

- Cronjobs Engine
  - Scheduler with cron expression and UI builder, timezone-aware next-run calculation.
  - Triggers: time, event (webhook), conditional expression language.
  - Payload templating with secure secret injection and variable mapping.
  - Automation levels: suggest-only, approval-required, conditional-auto, bounded-autopilot.
  - Constraint enforcement at runtime (max actions, spend limits, allowed tools).
  - Retry/backoff policy, dead-letter queue, run artifact storage, cost accounting.
  - Scalable worker pool with concurrency controls and rate limiting.

- Approvals Workflow
  - Approval queue model with SLA timers, assignment, and escalation.
  - Diff generation for text/structured data and partial approval (modify inputs).
  - Threaded comments, role gating, and conversion to recurring Cronjob.

- Explainability & Reversible Actions
  - Rationale storage per action, structured metadata, and schema validation service.
  - Diff engine for code/docs/ledger entries and automated reversal scripts.
  - Permission checks before rollback, simulated dry-run rollback.
  - Immutable audit logs and artifact versioning.

- Connectors & Secrets Management
  - Connector SDK and registry with metadata, OAuth and API key flows.
  - Secrets vault integration (KMS/HashiCorp/Azure Key Vault) with scoped access.
  - Connector health monitoring, retries, and sandbox test mode.

- Activity & Audit Logging
  - Append-only audit store with export CSV/JSON, fast indexing, retention config, and signed/tamper-evident entries.
  - SIEM integration and webhook forwarding.

- Search & Filter
  - Full-text + structured search (Elasticsearch/OpenSearch), faceted filters, access control at query time, autocomplete and saved queries.

- Notifications & Webhooks
  - Notification service with adapters (email, in-app, webhook, Slack), configurable rules, delivery retries and DLQ, audit of notifications.

- Billing & Usage Metering
  - Usage metering per run (GPT credits, connectors), Stripe/Chargebee integration, quota enforcement, usage dashboard.

- Developer SDK & APIs
  - REST + gRPC endpoints for agent registration, run invocation, message traces, artifacts.
  - SDKs: Node, Python, Go with auth helpers and samples.
  - API rate limiting, versioning, sandbox keys, and full API docs.

- Performance, Monitoring & Backup
  - Observability: Prometheus + Grafana / OpenTelemetry, tracing, alerts.
  - Automated backups for artifacts and traces, DR plan, health checks.

### 3. User Journeys
Step-by-step flows for each user type:

- New Individual User (End User)
  1. Visit Landing Page ‚Üí Click Try Free ‚Üí Signup (email/OAuth) ‚Üí Email verification.
  2. Onboard flow: choose modules, connect 1‚Äì2 connectors (e.g., Google Calendar, GitHub), guided tour.
  3. Create first Cronjob via template (e.g., weekly digest): fill payload variables, set automation level to suggest-only.
  4. Run test execution ‚Üí inspect Run Details & Artifacts, view message trace and rationale.
  5. Approve suggested actions in Approvals Queue ‚Üí see action executed ‚Üí view audit and optional rollback.

- Developer / Engineering Lead
  1. Signup via SSO ‚Üí Connect GitHub and CI provider ‚Üí Navigate to Projects module.
  2. Create an agent from template (PR triage), configure tools and permissions, test run.
  3. Create Cronjob to auto-triage nightly PRs with automation level approval-required.
  4. Review nightly Approval items, approve safe changes; gradually increase automation to bounded-autopilot.
  5. Use Run Details to inspect diffs and trigger rollback for erroneous changes.

- Content Creator / Manager
  1. Signup ‚Üí Connect CMS & social accounts ‚Üí Open Content module.
  2. Use Idea Inbox and agent outlines to generate drafts; iterate in Editor workspace with citations.
  3. Schedule publish via Cronjob with conditional trigger (e.g., analytics threshold) and approval-required.
  4. Monitor published performance; feed analytics to agent for future suggestions.

- Finance Manager
  1. Signup ‚Üí Connect bank aggregator (Plaid) ‚Üí Open Finance module.
  2. Configure Transactions Feed with agent auto-categorization (suggest-only).
  3. Create Cronjob for monthly close with constraints (max ledger changes, approval-required).
  4. Review anomalies flagged by agents in Approvals Queue, approve or modify adjustments.
  5. Export GL and store artifacts for audit.

- Health User / Coach
  1. Signup ‚Üí Connect fitness trackers and calendar ‚Üí Open Health module.
  2. Create goals and generate training plan via agent wizard; schedule plan deployments via Cronjob.
  3. Agents send periodic check-ins and adapt plan; user approves modifications as needed.
  4. Track adherence metrics and adjust automation levels.

- Admin / Org Owner
  1. SSO signup as admin ‚Üí Go to Admin Dashboard ‚Üí Configure RBAC, seats, billing.
  2. Set global automation defaults and safety policies; enable enterprise connectors (SAML, on-prem runners).
  3. Monitor connector health and Cronjob reliability metrics; manage approvals SLAs and escalations.
  4. Audit critical runs, export logs for compliance, orchestrate disaster recovery drills.

## UI Guide
Apply the design system consistently. All UI components must adhere to the Visual Style and Design Philosophy below.

## Visual Style

### Color Palette:
- Primary background: Deep charcoal black (#18181B).
- Secondary background: Slightly lighter dark gray (#232326, #242426).
- Accent colors: Vivid orange (#FF7300); soft green (#3FC56B); purple (#B16FFF).
- Borders/dividers: Semi-transparent gray (#2E2E32, #37373C).
- Text: White (#FFFFFF), off-white (#E5E7EB), muted gray (#A1A1AA).
- Interactive states: Light gray (#313136); thin neon color bars for active tags.
- Surface elevation: Subtle dark gradients and overlays.

### Typography & Layout:
- Font family: Modern geometric sans-serif (Inter / SF Pro).
- Weights: Headings 600‚Äì700; body 400‚Äì500.
- Spacing: Card padding 24‚Äì32px; list spacing 8‚Äì16px.
- Alignment: Left-aligned content with strong grid.

### Key Design Elements

- Card Design
  - Rounded corners (10‚Äì14px), dark backgrounds, subtle shadows/border-glows.
  - Optional color-coded sidebars for status.
  - Hover lift and brightness increase.

- Navigation
  - Fixed collapsible sidebar; slim top nav for global actions.
  - Smooth expand/collapse animations.

- Data Visualization
  - Flat neon-accented charts (orange/green/purple) on dark backgrounds.
  - Minimalist legends and muted labels.

- Interactive Elements
  - Buttons: Rounded rectangles; primary accent orange.
  - Form fields: Rounded dark inputs, clear accent focus outline.
  - Micro-interactions: Smooth transitions for modals/popovers/drag-and-drop.

### Design Philosophy
- Minimalist, information-dense, dark-first UI.
- Rounded approachable shapes with precise grids.
- Guided discovery, progressive disclosure, and reduced cognitive load.
- Enterprise-grade trust: clarity, traceability, and safe controls.

Implementation notes: Use dark palettes and typographic hierarchy consistently across pages. Provide accessible color contrasts and keyboard/mouse interactions.

## Instructions to AI Development Tool
1. Refer to Project Concept, Problem Statement, and Solution to preserve the "why" for each requirement.
2. Ensure all features and pages align with solving identified problems and user journeys.
3. Verify features and pages meet specifications before marking complete.
4. Enforce the UI Guide strictly: color palette, typography, spacing, and component behavior.
5. Maintain consistency with the solution approach, security, explainability, and reversibility across implementation.

---

Appendix: Technical Integrations & Assets Summary
- APIs: OpenAI/GPT‚Äë5, OAuth providers (Google, Microsoft, GitHub), GitHub/GitLab, CI/CD providers, CMS & Social APIs, Plaid/aggregators, fitness trackers, SendGrid/Mailgun, Stripe/Chargebee, AWS S3/Azure Blob, Elasticsearch/OpenSearch.
- Assets: Brand logos (light/dark), Design System UI Kit, illustrations & icons (SVG), onboarding copy & tour, marketing assets, agent persona templates, Cronjob example templates, API/SDK samples.
- Observability: Prometheus + Grafana / OpenTelemetry, backup schedule, DR playbook.
- Security: KMS/HashiCorp/Azure Key Vault for secrets, RBAC, signed audit logs, encryption in transit/at rest.

This blueprint provides the full context and specifications to implement LifeOps: architecture, pages, features, flows, UI system, integrations, and assets. Build to these specs to deliver a secure, auditable, and modular multi-agent automation platform.


IMPLEMENTATION INSTRUCTIONS:
1. Follow the DESIGN REFERENCE section above EXACTLY for ALL UI/UX implementation
2. Implement colors, typography, spacing, shadows, and animations EXACTLY as specified in Design Reference
3. Read and understand ALL boilerplate documentation above for architecture patterns
4. Follow the dependency versions EXACTLY as specified
5. Use the project structure outlined in the documentation
6. Use Tailwind CSS animations with custom keyframes (NOT Motion library or framer-motion)
7. Use native fetch() with the API utilities pattern in src/lib/api.ts
8. Use Recharts for all data visualization and charts
9. Use @tailwindcss/typography plugin for rich text content
10. Use Zod for form validation
11. Install ALL shadcn/ui components: npx shadcn@latest add button input card toast dialog select tabs accordion alert-dialog avatar checkbox collapsible dropdown-menu hover-card label menubar navigation-menu popover progress radio-group scroll-area separator slider switch toggle tooltip aspect-ratio breadcrumb calendar carousel command context-menu drawer form input-otp pagination resizable sheet skeleton table textarea toggle-group
12. Use Shadcn UI for all components
13. Build the components first, then the pages, make to not import non-existent components or types
14. Use Sonner for toast notifications
15. Build the design system based on Design Reference specifications above
16. Implement the user's requirements: # LifeOps ‚Äî Development Blueprint

## Project Concept
LifeOps is a modular, multi-agent AI operating system that automates projects, content, finances, and health through coordinated GPT-5‚Äìpowered agents. It provides a Master Dashboard and module dashboards (Projects, Content, Finance, Health), an orchestration layer for traceable agent-to-agent messages, scoped shared memory, conflict resolution rules, and a Cronjobs system treating scheduled autonomy as first-class objects. Each action is explainable, permissioned, schema-validated, logged, and reversible. The vision is an enterprise-grade, AI-native orchestration platform enabling safe, auditable, and configurable autonomous assistants for power users, teams, and orgs.

AI app description: Specialized agents per domain communicate through an ordered message bus and runtime abstraction. Cronjobs schedule or trigger agents/workflows with rich constraints, safety rails, and approval levels. The platform emphasizes explainability, reversibility, and full audit artifacts while integrating with external systems (VCS, CI/CD, CMS, banks, fitness trackers).

## Problem Statement
- Core problems:
  - Knowledge workers and teams spend repeated time on recurring operational tasks (triage PRs, monthly close, content pipelines, training plans).
  - Existing single-agent automations lack multi-agent coordination, traceability, and safe rollback.
  - Scheduled autonomy is often brittle or all-or-nothing without fine-grained controls and human-in-the-loop approvals.
  - Integrations across VCS, CI, finance, CMS and trackers are fragmented and hard to orchestrate with explainability and compliance.
- Who experiences these problems:
  - Individual founders, knowledge workers, content teams, finance managers, coaches/athletes, and org admins.
- Why these problems matter:
  - Time wasted, risky automated actions, lack of auditability, compliance exposure, and lost trust hinder adoption.
- Current state/gaps:
  - Tools either provide basic scheduling or heavy RPA but lack AI-native multi-agent orchestration, reversible actions, and first-class Cronjob objects with safety/approval controls.

## Solution
- How it addresses problems:
  - Multi-agent orchestration enables domain-specific agents to negotiate, handoff, and reach consensus with traceable messages and shared scoped memory.
  - Cronjobs as first-class objects provide safe scheduled autonomy with templated payloads, automation levels, constraints, retries and run artifacts.
  - Explainability and reversible actions (diffs, rollback scripts, schema validation) build trust and compliance.
  - Rich connectors and developer SDKs allow deep integration with VCS, CI, CMS, banks, trackers, and email/billing.
- Approach & methodology:
  - Modular architecture: agent runtime, message bus, cron engine, approvals layer, connectors/secret vault, UI frontends per module, REST/gRPC APIs, and SDKs.
  - Security & compliance-first: RBAC, audit logs, tamper-evident entries, encryption, and optional on-prem runners.
  - Progressive disclosure UX with templates and guided onboarding to reduce complexity.
- Key differentiators:
  - First-class Cronjobs with automation levels and full run artifacts.
  - Explainability stored alongside actions and schema-validated outputs enabling safe reversals.
  - Developer-centric project automation integrated with release orchestration and CI.
- Value creation:
  - Saves operational time, reduces human error, increases trust in automation, and unlocks new workflows through reusable templates and marketplace.

## Requirements

### 1. Pages (UI Screens)
List of pages with purpose, key components, and contribution:

- Landing Page (Public marketing)
  - Purpose: Communicate value, convert visitors to signups/demos.
  - Key sections: Hero, Feature Overview (Projects, Content, Finance, Health), Cronjobs & Approvals Snapshot, Use Cases, Pricing Teaser, Footer.
  - Contribution: Drives acquisition and explains first-class Cronjobs and agent benefits.

- Login / Signup
  - Purpose: Authentication entrypoint.
  - Key components: Email/password forms, SSO/Social buttons (Google, Microsoft, GitHub), password strength meter, TOS checkbox.
  - Contribution: Secure onboarding and SSO for enterprise users.

- Email Verification
  - Purpose: Confirm user ownership of email.
  - Key components: Verification message, resend button (rate limited), manual 6-digit code input.
  - Contribution: Security & account trust.

- Password Reset
  - Purpose: Secure recovery flow.
  - Key components: Request form, reset form with token validation, strength meter.
  - Contribution: Account safety and accessibility.

- Master Dashboard
  - Purpose: Single command center for system health and orchestration.
  - Key components: Top nav (search, avatar, org switch), System Overview cards, Cronjobs Timeline (list/calendar), Active Runs Feed, Alerts Panel, Audit Snapshot, Quick Create.
  - Contribution: Central monitoring and quick control for automation.

- Agent Directory
  - Purpose: Manage agents (system/user).
  - Key components: Filterable list, agent details (capabilities, memory scope, connectors), Create Agent Wizard, actions (clone/archive), message trace viewer.
  - Contribution: Visibility and lifecycle management for agents.

- Module Dashboard ‚Äî Projects
  - Purpose: Developer-centric automation (roadmaps, tickets, CI).
  - Key components: Project selector, Roadmap timeline, Ticket Board (Kanban with auto-triage), PR & Release pane, Integrations panel.
  - Contribution: Automates developer workflows and release orchestration.

- Module Dashboard ‚Äî Content
  - Purpose: End-to-end content pipeline automation.
  - Key components: Content calendar, Idea inbox (agent outlines), Editor workspace with suggestions and versioning, publishing connectors, analytics.
  - Contribution: Streamlines content creation and publishing.

- Module Dashboard ‚Äî Finance
  - Purpose: Automate bookkeeping, forecasting, anomalies.
  - Key components: Accounts overview, transactions feed with agent suggestions, subscriptions manager, forecasting & close workspace, export & audit.
  - Contribution: Reduce month-end effort and ensure traceable financial actions.

- Module Dashboard ‚Äî Health
  - Purpose: Automate habits, training plans, recovery balancing.
  - Key components: Habits & goals, training plans with calendar sync, nutrition planner, recovery/load insights, device integrations.
  - Contribution: Personalized coaching and automated planning.

- Cronjobs Manager
  - Purpose: CRUD and visualize Cronjobs as first-class objects.
  - Key components: Cronjob list (next run, last outcome), Cronjob details (payload, constraints, safety rails), Schedule builder UI, Create/Edit wizard, run controls.
  - Contribution: Safe scheduling and governance for automated workflows.

- Workflow Template Library
  - Purpose: Reusable multi-agent workflow templates.
  - Key components: Template catalog, template details, import & customize flow, rating & comments.
  - Contribution: Accelerates adoption with prebuilt workflows.

- Approvals Queue
  - Purpose: Human-in-the-loop reviews for pending actions.
  - Key components: Approvals list with SLA timers, approval details (diffs, artifacts), decision controls (approve/reject/modify), threaded comments.
  - Contribution: Safety and auditability for automation.

- Run Details & Artifacts
  - Purpose: Inspect single run with full artifacts and rollback.
  - Key components: Run summary, message trace viewer, action diffs (side-by-side), artifacts panel, rollback controls.
  - Contribution: Explainability and reversible actions.

- User Profile
  - Purpose: Manage personal settings and API keys.
  - Key components: Profile info, connections, API keys, agent presets, security (2FA).
  - Contribution: User-level control and developer access.

- Organization / Team Settings
  - Purpose: Manage teams, RBAC, billing, enterprise config.
  - Key components: Team roster, RBAC policies, billing, enterprise options (SAML, on‚Äëprem).
  - Contribution: Governance and enterprise controls.

- Settings & Preferences
  - Purpose: Global app settings and defaults.
  - Key components: Notification rules, automation defaults, data retention, developer settings.
  - Contribution: Platform customization and compliance.

- Admin Dashboard
  - Purpose: System admin controls and monitoring.
  - Key components: User management, system health, analytics, policy management.
  - Contribution: Operational reliability and policy enforcement.

- Integration Connectors
  - Purpose: Catalog and configure external connectors.
  - Key components: Connector catalog, setup wizard (OAuth/API key), secrets management, health panel.
  - Contribution: Enables workflow integrations.

- Docs & Help
  - Purpose: Documentation, tutorials, API docs.
  - Key components: Searchable docs, tutorials, support contact, changelog & status.
  - Contribution: Self-service enablement and onboarding.

- Privacy Policy, Terms of Service, Cookie Policy
  - Purpose: Legal and compliance pages.
  - Contribution: Regulatory and legal compliance.

- 404 Not Found / 500 Server Error
  - Purpose: User-friendly error handling.
  - Contribution: UX resilience and support guidance.

- Loading & Success States
  - Purpose: Standardized feedback components.
  - Contribution: Polished UX and clarity.

### 2. Features
Core features with technical details and implementation notes:

- User Authentication & Security
  - JWT access/refresh tokens, secure refresh flow.
  - OAuth2 (Google, Microsoft, GitHub), SAML for enterprise.
  - Password hashing with bcrypt/argon2, password policy enforcement.
  - Email verification with expiring tokens; TOTP 2FA with recovery codes.
  - Session management dashboard and revocation APIs.
  - Rate limiting & account lockout.

- Agent Orchestration Layer
  - Message bus (ordered, durable) with persistent traces (append-only store).
  - Agent runtime abstraction with pluggable skills/tools (connectors).
  - Scoped shared memory with ACLs, versioning and conflict resolution engine (rules: user constraints > safety > deadlines > ROI).
  - Explainability hooks (store rationales), schema validation for outputs, and audit logging.
  - APIs for agent registration, runtime telemetry, and tracing.

- Cronjobs Engine
  - Scheduler with cron expression and UI builder, timezone-aware next-run calculation.
  - Triggers: time, event (webhook), conditional expression language.
  - Payload templating with secure secret injection and variable mapping.
  - Automation levels: suggest-only, approval-required, conditional-auto, bounded-autopilot.
  - Constraint enforcement at runtime (max actions, spend limits, allowed tools).
  - Retry/backoff policy, dead-letter queue, run artifact storage, cost accounting.
  - Scalable worker pool with concurrency controls and rate limiting.

- Approvals Workflow
  - Approval queue model with SLA timers, assignment, and escalation.
  - Diff generation for text/structured data and partial approval (modify inputs).
  - Threaded comments, role gating, and conversion to recurring Cronjob.

- Explainability & Reversible Actions
  - Rationale storage per action, structured metadata, and schema validation service.
  - Diff engine for code/docs/ledger entries and automated reversal scripts.
  - Permission checks before rollback, simulated dry-run rollback.
  - Immutable audit logs and artifact versioning.

- Connectors & Secrets Management
  - Connector SDK and registry with metadata, OAuth and API key flows.
  - Secrets vault integration (KMS/HashiCorp/Azure Key Vault) with scoped access.
  - Connector health monitoring, retries, and sandbox test mode.

- Activity & Audit Logging
  - Append-only audit store with export CSV/JSON, fast indexing, retention config, and signed/tamper-evident entries.
  - SIEM integration and webhook forwarding.

- Search & Filter
  - Full-text + structured search (Elasticsearch/OpenSearch), faceted filters, access control at query time, autocomplete and saved queries.

- Notifications & Webhooks
  - Notification service with adapters (email, in-app, webhook, Slack), configurable rules, delivery retries and DLQ, audit of notifications.

- Billing & Usage Metering
  - Usage metering per run (GPT credits, connectors), Stripe/Chargebee integration, quota enforcement, usage dashboard.

- Developer SDK & APIs
  - REST + gRPC endpoints for agent registration, run invocation, message traces, artifacts.
  - SDKs: Node, Python, Go with auth helpers and samples.
  - API rate limiting, versioning, sandbox keys, and full API docs.

- Performance, Monitoring & Backup
  - Observability: Prometheus + Grafana / OpenTelemetry, tracing, alerts.
  - Automated backups for artifacts and traces, DR plan, health checks.

### 3. User Journeys
Step-by-step flows for each user type:

- New Individual User (End User)
  1. Visit Landing Page ‚Üí Click Try Free ‚Üí Signup (email/OAuth) ‚Üí Email verification.
  2. Onboard flow: choose modules, connect 1‚Äì2 connectors (e.g., Google Calendar, GitHub), guided tour.
  3. Create first Cronjob via template (e.g., weekly digest): fill payload variables, set automation level to suggest-only.
  4. Run test execution ‚Üí inspect Run Details & Artifacts, view message trace and rationale.
  5. Approve suggested actions in Approvals Queue ‚Üí see action executed ‚Üí view audit and optional rollback.

- Developer / Engineering Lead
  1. Signup via SSO ‚Üí Connect GitHub and CI provider ‚Üí Navigate to Projects module.
  2. Create an agent from template (PR triage), configure tools and permissions, test run.
  3. Create Cronjob to auto-triage nightly PRs with automation level approval-required.
  4. Review nightly Approval items, approve safe changes; gradually increase automation to bounded-autopilot.
  5. Use Run Details to inspect diffs and trigger rollback for erroneous changes.

- Content Creator / Manager
  1. Signup ‚Üí Connect CMS & social accounts ‚Üí Open Content module.
  2. Use Idea Inbox and agent outlines to generate drafts; iterate in Editor workspace with citations.
  3. Schedule publish via Cronjob with conditional trigger (e.g., analytics threshold) and approval-required.
  4. Monitor published performance; feed analytics to agent for future suggestions.

- Finance Manager
  1. Signup ‚Üí Connect bank aggregator (Plaid) ‚Üí Open Finance module.
  2. Configure Transactions Feed with agent auto-categorization (suggest-only).
  3. Create Cronjob for monthly close with constraints (max ledger changes, approval-required).
  4. Review anomalies flagged by agents in Approvals Queue, approve or modify adjustments.
  5. Export GL and store artifacts for audit.

- Health User / Coach
  1. Signup ‚Üí Connect fitness trackers and calendar ‚Üí Open Health module.
  2. Create goals and generate training plan via agent wizard; schedule plan deployments via Cronjob.
  3. Agents send periodic check-ins and adapt plan; user approves modifications as needed.
  4. Track adherence metrics and adjust automation levels.

- Admin / Org Owner
  1. SSO signup as admin ‚Üí Go to Admin Dashboard ‚Üí Configure RBAC, seats, billing.
  2. Set global automation defaults and safety policies; enable enterprise connectors (SAML, on-prem runners).
  3. Monitor connector health and Cronjob reliability metrics; manage approvals SLAs and escalations.
  4. Audit critical runs, export logs for compliance, orchestrate disaster recovery drills.

## UI Guide
Apply the design system consistently. All UI components must adhere to the Visual Style and Design Philosophy below.

## Visual Style

### Color Palette:
- Primary background: Deep charcoal black (#18181B).
- Secondary background: Slightly lighter dark gray (#232326, #242426).
- Accent colors: Vivid orange (#FF7300); soft green (#3FC56B); purple (#B16FFF).
- Borders/dividers: Semi-transparent gray (#2E2E32, #37373C).
- Text: White (#FFFFFF), off-white (#E5E7EB), muted gray (#A1A1AA).
- Interactive states: Light gray (#313136); thin neon color bars for active tags.
- Surface elevation: Subtle dark gradients and overlays.

### Typography & Layout:
- Font family: Modern geometric sans-serif (Inter / SF Pro).
- Weights: Headings 600‚Äì700; body 400‚Äì500.
- Spacing: Card padding 24‚Äì32px; list spacing 8‚Äì16px.
- Alignment: Left-aligned content with strong grid.

### Key Design Elements

- Card Design
  - Rounded corners (10‚Äì14px), dark backgrounds, subtle shadows/border-glows.
  - Optional color-coded sidebars for status.
  - Hover lift and brightness increase.

- Navigation
  - Fixed collapsible sidebar; slim top nav for global actions.
  - Smooth expand/collapse animations.

- Data Visualization
  - Flat neon-accented charts (orange/green/purple) on dark backgrounds.
  - Minimalist legends and muted labels.

- Interactive Elements
  - Buttons: Rounded rectangles; primary accent orange.
  - Form fields: Rounded dark inputs, clear accent focus outline.
  - Micro-interactions: Smooth transitions for modals/popovers/drag-and-drop.

### Design Philosophy
- Minimalist, information-dense, dark-first UI.
- Rounded approachable shapes with precise grids.
- Guided discovery, progressive disclosure, and reduced cognitive load.
- Enterprise-grade trust: clarity, traceability, and safe controls.

Implementation notes: Use dark palettes and typographic hierarchy consistently across pages. Provide accessible color contrasts and keyboard/mouse interactions.

## Instructions to AI Development Tool
1. Refer to Project Concept, Problem Statement, and Solution to preserve the "why" for each requirement.
2. Ensure all features and pages align with solving identified problems and user journeys.
3. Verify features and pages meet specifications before marking complete.
4. Enforce the UI Guide strictly: color palette, typography, spacing, and component behavior.
5. Maintain consistency with the solution approach, security, explainability, and reversibility across implementation.

---

Appendix: Technical Integrations & Assets Summary
- APIs: OpenAI/GPT‚Äë5, OAuth providers (Google, Microsoft, GitHub), GitHub/GitLab, CI/CD providers, CMS & Social APIs, Plaid/aggregators, fitness trackers, SendGrid/Mailgun, Stripe/Chargebee, AWS S3/Azure Blob, Elasticsearch/OpenSearch.
- Assets: Brand logos (light/dark), Design System UI Kit, illustrations & icons (SVG), onboarding copy & tour, marketing assets, agent persona templates, Cronjob example templates, API/SDK samples.
- Observability: Prometheus + Grafana / OpenTelemetry, backup schedule, DR playbook.
- Security: KMS/HashiCorp/Azure Key Vault for secrets, RBAC, signed audit logs, encryption in transit/at rest.

This blueprint provides the full context and specifications to implement LifeOps: architecture, pages, features, flows, UI system, integrations, and assets. Build to these specs to deliver a secure, auditable, and modular multi-agent automation platform.
17. When Supabase is configured: use Edge Functions for LLM calls and server-only logic; never expose LLM or third-party API keys in the client.

START IMPLEMENTING NOW. Do not ask questions - analyze the existing project and build according to the specifications above.